#!/usr/bin/env python3
# created at Jul 19, 2017 16:11 by Qi Zhang

import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties

from miscellaneous.phonon import *
from output.read_file import *


class PlotPWscfOutput:
    def __init__(self):
        self.rpw = ReadPWscfOutput()

    def plot_e_vs_k_num(self, filename: str):
        e_list = self.rpw.read_total_energy(filename)
        pass


class PlotVCRelaxOutput:
    def __init__(self):
        self.ro = ReadVCRelaxOutput()
        self.cmap = plt.get_cmap('nipy_spectral')

    def parse_filenames(self, filename_list):
        pass

    def plot_p_vs_v(self, files: list):
        colors = self.cmap(np.linspace(0, 1, len(files)))
        labels = [file.split(".")[1] for file in files]
        fig, ax = plt.subplots()
        for i, file in enumerate(files):
            [p, v] = self.ro.read_pv(file)
            ax.plot(p, v, 'o-', label=labels[i], color=colors[i])

    def plot_vinet_eos(self, ax):
        # p is a function takes 1 parameter.
        pass

    def plot_v0_vs_temp(self, file_list: List[str]) -> None:
        v0_list = self.ro.read_v0_from_files(file_list)
        temp_list = []
        fig, ax = plt.subplots()
        ax.plot(temp_list, v0_list)
        ax.set_title("$V_0$ vs $T$", fontsize=16)
        ax.set_xlabel("$T$ (K)", fontsize=12)
        ax.set_ylabel("$V_0$ (au$^3$)", fontsize=12)
        plt.show()

    @staticmethod
    def plot_iternum_vs_p(files: list, ax):
        r = ReadVCRelaxOutput()
        for file in files:
            [p, iternum] = r.read_iter_num(file)
            ax.plot(p, iternum)
        ax.set_title('iteration numbers vs pressures on different tests', fontsize=16)
        ax.set_xlabel('pressures (GPa)', fontsize=12)
        ax.set_ylabel('iteration numbers', fontsize=12)


class PlotPHononOutput:
    def __init__(self, q_path: str):
        """

        :param q_path: A `q_path` is something like 'Γ->M->K->Γ->A->K', indicating the q-point path you are going
            through. Spaces are allowed in this string.
        """
        self.q_path = q_path.upper().replace(' ', '').split('->')
        self.rph = ReadPHononOutput()
        self.cph = ComputePHonon()

    def plot_gnuplot(self, filename: Optional[str] = 'gnuplot'):
        coords_list, bands_list = self.rph.read_gunplot(filename)
        fig, ax = plt.subplots()
        # for i, p in enumerate(zip(coords_list, bands_list)):
        #     ax.plot(*p, label="band " + str(i))
        ax.plot(coords_list, bands_list)
        # Next we will make some adjustment to plot all bands.
        box = ax.get_position()
        ax.set_position([box.x0, box.y0 + box.height * 0.2,
                         box.width, box.height * 0.8])
        fontp = FontProperties()
        fontp.set_size('small')
        ax.legend(loc='center', bbox_to_anchor=(0.5, -0.25), ncol=3, prop=fontp)
        ax.set_xlabel('k-points', fontsize=12)
        ax.set_ylabel("frequency (cm$^{-1})$", fontsize=12)
        ax.set_title('phonon dispersion relation', fontsize=16)

    def generate_plotting_data(self, filename: str, density: IntArray):
        """
        I write this method because I want to separate data generation and plotting steps.

        :param filename:
        :param density:
        :return:
        """
        path_num = len(density)
        qs, bands = self.rph.read_phonon_dispersion(filename, density)
        lens = self.cph.q_path_len_list(path_num, qs)
        return qs, bands, lens

    def plot_phonon_dispersion(self, data, color: Optional[str] = 'g', option: Optional[str] = 'hz'):
        """
        This method is used to plot a phonon dispersion relation for one output given by matdyn.x.

        :param data: This data is generated by `generate_plotting_data`.
        :param color: Color for the manifold. The default value is green.
        :param option: Specify energy unit, you can input 'hz' for hertz, 'thz' for tera-hertz, 'ev' for electron-volt.
            The option is case-insensitive.
        :return:
        """
        qs, bands, lens = data
        fig, axes = plt.subplots(1, len(lens), gridspec_kw={'width_ratios': lens}, sharey='all')

        if re.match('hz', option, flags=re.IGNORECASE):
            option = 'Hz'
            bands = self.cph.frequency_to_hertz(bands)
        elif re.match('thz', option, flags=re.IGNORECASE):
            option = 'THz'
            bands = self.cph.frequency_to_hertz(bands) / 1e12
        elif re.match('ev', option, flags=re.IGNORECASE):
            bands = self.cph.frequency_to_ev(bands)
        else:
            raise ValueError('Unknown option ' + str(option) + ' given!')

        # Main plotting code block
        for i, ax in enumerate(axes):
            x_coordinates = range(len(qs[i]))  # Remap q-points coordinates to x coordinates for plotting
            ax.yaxis.set_ticks_position('none')  # Remove side effect
            ax.plot(x_coordinates, bands[i], color=color)
            ax.get_xaxis().set_ticks([])  # Cancel x-axis ticks
            ax.set_xticks([0, len(qs[i])])  # Specify new ticks position
            ax.set_xticklabels(self.q_path[i])  # Put ticks on x-axis
            ax.set_xlim((min(x_coordinates), max(x_coordinates)))  # To make plot without inner paddings

        axes[0].set_ylabel(option, fontsize=12)  # Vertical label
        axes[0].yaxis.tick_left()  # Put label on the left

        axes[-1].set_xticks([0, len(qs[-1])])
        axes[-1].set_xticklabels([self.q_path[-2], self.q_path[-1]])
        axes[-1].yaxis.tick_right()
        axes[-1].yaxis.set_ticks_position('right')

        fig.text(0.5, 0.02, 'q-path', fontsize=12)  # Horizontal label
        fig.subplots_adjust(wspace=0, hspace=0)  # Remove spaces between subplots
        return fig, axes

    def plot_multiple_phonon_dispersion(self, files: List[str], density, option):
        colormap = plt.get_cmap('viridis')
        colors: np.ndarray = colormap(np.linspace(0, 1, len(files)))
        qs, bands, lens = self.generate_plotting_data(files[0], density)
        fig, axes = plt.subplots(1, len(lens), gridspec_kw={'width_ratios': lens}, sharey='all')

        font_p = FontProperties()
        font_p.set_size('small')

        for j, file in enumerate(files):
            qs, bands, lens = self.generate_plotting_data(file, density)

            if re.match('hz', option, flags=re.IGNORECASE):
                option = 'Hz'
                bands = self.cph.frequency_to_hertz(bands)
            elif re.match('thz', option, flags=re.IGNORECASE):
                option = 'THz'
                bands = self.cph.frequency_to_hertz(bands) / 1e12
            elif re.match('ev', option, flags=re.IGNORECASE):
                bands = self.cph.frequency_to_ev(bands)
            else:
                raise ValueError('Unknown option ' + str(option) + ' given!')

            for i, ax in enumerate(axes):
                x_coordinates = range(len(qs[i]))  # Remap q-points coordinates to x coordinates for plotting
                ax.yaxis.set_ticks_position('none')  # Remove side effect
                ax.plot(x_coordinates, bands[i], color=colors[j], label=file)
                ax.get_xaxis().set_ticks([])  # Cancel x-axis ticks
                ax.set_xticks([0, len(qs[i])])  # Specify new ticks position
                ax.set_xticklabels(self.q_path[i])  # Put ticks on x-axis
                ax.set_xlim((min(x_coordinates), max(x_coordinates)))  # To make plot without inner paddings
                box = ax.get_position()
                ax.set_position([box.x0, 0.4, box.width, 0.4])

            # Combine multiple line labels into one legend
            handles, labels = axes[-1].get_legend_handles_labels()
            labels, ids = np.unique(labels, return_index=True)
            handles = [handles[i] for i in ids]
            plt.legend(handles, labels, ncol=1, prop=font_p)

        axes[0].set_ylabel(option, fontsize=12)  # Vertical label
        axes[0].yaxis.tick_left()  # Put label on the left

        axes[-1].set_xticks([0, len(qs[-1])])
        axes[-1].set_xticklabels([self.q_path[-2], self.q_path[-1]])
        axes[-1].yaxis.tick_right()
        axes[-1].yaxis.set_ticks_position('right')

        fig.text(0.5, 0.02, 'q-path', fontsize=12)  # Horizontal label
        fig.subplots_adjust(wspace=0, hspace=0)  # Remove spaces between subplots
        return fig, axes

    def plot_dos(self, filename: Optional[str] = 'matdyn.dos.out', freq_unit: Optional[str] = 'ev',
                 mode: Optional[str] = 'preview') -> None:
        """
        This method plots the density of states (DOS) of a phonon dispersion relation.

        :param filename: file that contains DOS-data. The default value is 'matdyn.dos.out'.
        :param freq_unit: You can choose from 'ev' or 'cm-1'. The default value is 'ev'.
        :param mode: You can choose to preview/show the plot ('preview') or save it to file ('save'). The default value
            is 'preview'.
        :return: None
        """
        fig, ax = plt.subplots()
        frequency_list, dos_list = self.rph.read_dos(filename)
        if freq_unit == 'ev':
            frequency_list = self.cph.frequency_to_ev(frequency_list)  # Convert unit from cm^-1 to ev
            ax.set_xlabel("electron-volt", fontsize=12)
        elif freq_unit == 'cm-1':
            ax.set_xlabel("frequency (cm$^{-1})$", fontsize=12)
        elif freq_unit == 'thz':
            frequency_list = list(map(lambda x: x * 0.02998, frequency_list))
            ax.set_xlabel("frequency (THz)", fontsize=12)
        else:
            raise ValueError('Unknown frequency unit!')

        ax.set_xlim((min(frequency_list), max(frequency_list)))
        ax.set_ylim((0, max(dos_list)))
        ax.plot(frequency_list, dos_list)
        ax.set_ylabel('density of states', fontsize=12)
        ax.set_title('phonon density of states', fontsize=16)

        if mode == 'preview':
            plt.show()
        elif mode == 'save':
            plt.savefig("dos.pdf")
        else:
            raise ValueError('Unknown output mode!')


class PlotElasticityOutput:
    def __init__(self):
        self.reo = ReadElasticityOutput()

    def plot_cij_vs_pressures(self, inp: str):
        data = self.reo.read_cij_vs_pressures(inp)
        fig, ax = plt.subplots()
        for i, p in enumerate(zip(data.keys(), data.values())):
            for pp in zip([float(p[0])] * len(p[1]), p[1]):
                print(*pp)
                ax.scatter(*pp, label="value" + str(i))
        return fig, ax
